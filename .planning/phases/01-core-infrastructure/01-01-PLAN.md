---
phase: 01-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/event_bus.py
  - src/core/config.py
  - src/core/logging_config.py
  - src/core/safe_write.py
  - tests/core/test_event_bus.py
  - tests/core/test_safe_write.py
autonomous: true
requirements:
  - CORE-01
  - CORE-05
  - CORE-06
  - CORE-03
must_haves:
  truths:
    - Event bus handles lifecycle events (input.received, note.routed, heartbeat.tick, day.ended)
    - Configuration loads from YAML and per-plugin user-data.json
    - Logging writes to verbose.log and error.log with plugin attribution
    - Safe write protocol prevents file corruption with atomic operations
  artifacts:
    - path: src/core/event_bus.py
      provides: Signal definitions and event handling
      exports: ["input_received", "note_routed", "note_written", "heartbeat_tick", "day_ended", "pipeline_error"]
    - path: src/core/config.py
      provides: Configuration management
      exports: ["Config", "get_config"]
    - path: src/core/logging_config.py
      provides: Plugin-attributed logging
      exports: ["get_logger", "setup_logging"]
    - path: src/core/safe_write.py
      provides: Atomic file writes
      exports: ["safe_write", "SafeWriteError"]
  key_links:
    - from: src/core/event_bus.py
      to: All plugins
      via: Signal subscriptions
      pattern: "@signal.connect"
    - from: src/core/safe_write.py
      to: Daily writer, all file outputs
      via: Function calls
      pattern: "safe_write(filepath, content)"
---

<objective>
Create foundation layer: event bus, configuration, logging, and safe write protocol.
These are the core primitives all other components depend on.

Purpose: Establish zero-dependency foundation that enables plugin communication,
persistent configuration, structured logging, and safe file operations.

Output: 4 core modules with tests, working in isolation but ready for integration.
</objective>

<execution_context>
@/Users/caffae/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/caffae/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Event Bus System</name>
  <files>src/core/event_bus.py, tests/core/test_event_bus.py</files>
  <action>
    Create event bus using blinker library. Define lifecycle signals:
    - input_received: emitted when new input captured (text, source)
    - note_routed: emitted when note classified (text, destination)
    - note_written: emitted when file written (path, timestamp, word_count, source)
    - heartbeat_tick: periodic system pulse (timestamp)
    - day_ended: end of day trigger (date)
    - pipeline_error: processing error (error, context)
    
    Each signal should support sender identification and kwargs payload.
    Include decorator-based subscription helper.
    
    Test: Verify signal emission and reception, sender identification, multiple subscribers.
  </action>
  <verify>python -m pytest tests/core/test_event_bus.py -v</verify>
  <done>All 6 signals defined and tested; decorators work; thread-safety verified</done>
</task>

<task type="auto">
  <name>Task 2: Configuration System</name>
  <files>src/core/config.py, tests/core/test_config.py</files>
  <action>
    Create configuration management system:
    - Load ~/.butler/config.yaml (main config)
    - Per-plugin config: ~/.butler/plugins/{name}.yaml
    - Per-plugin state: ~/.butler/plugins/{name}/user-data.json
    - Support nested access: config.get("vault.path")
    - Auto-create directory structure on first run
    - Default values for all settings
    - Save methods for plugin state persistence
    
    Key settings: vault_path, log_level, plugins_dir, data_dir
    
    Test: Config loading, default fallbacks, nested access, save/load plugin data.
  </action>
  <verify>python -m pytest tests/core/test_config.py -v</verify>
  <done>Config loads from YAML; plugin configs work; user-data.json persists state</done>
</task>

<task type="auto">
  <name>Task 3: Logging System</name>
  <files>src/core/logging_config.py, tests/core/test_logging.py</files>
  <action>
    Create logging infrastructure:
    - verbose.log: DEBUG level, all messages
    - error.log: WARNING level, errors only
    - Plugin attribution via LoggerAdapter pattern
    - Format: [timestamp] [level] [plugin] message
    - Log rotation (10MB per file, keep 3 backups)
    - Auto-create ~/.butler/logs/ directory
    
    API: get_logger(name, plugin="core") returns attributed logger
    
    Test: Log files created, plugin attribution works, rotation triggers.
  </action>
  <verify>python -m pytest tests/core/test_logging.py -v && ls ~/.butler/logs/</verify>
  <done>Two log files writing; plugin names appear in brackets; rotation configured</done>
</task>

<task type="auto">
  <name>Task 4: Safe Write Protocol</name>
  <files>src/core/safe_write.py, tests/core/test_safe_write.py</files>
  <action>
    Implement safe write protocol to prevent Obsidian race conditions:
    - Atomic temp+replace using tempfile in same directory
    - mtime double-check before and after write
    - Return success/failure status
    - Retry with exponential backoff on conflict
    - SafeWriteError exception for failures
    
    Algorithm:
    1. Record pre_mtime if file exists
    2. Write to temp file in same directory
    3. Atomic move (os.rename or shutil.move)
    4. Verify post_mtime differs from pre_mtime
    5. If conflict detected, retry up to 3 times
    
    Test: Concurrent writes, mtime detection, retry behavior, atomicity guarantee.
  </action>
  <verify>python -m pytest tests/core/test_safe_write.py -v</verify>
  <done>File writes are atomic; mtime conflicts detected; retries work; no data corruption</done>
</task>

</tasks>

<verification>
1. Import test: `python -c "from src.core.event_bus import input_received; from src.core.config import Config; from src.core.logging_config import get_logger; from src.core.safe_write import safe_write"`
2. Integration test: Event bus + logging work together (log on signal)
3. Safe write stress test: 100 concurrent writes, zero corruption
4. Config round-trip: Save → load → verify values preserved
</verification>

<success_criteria>
- All 4 core modules import without errors
- Tests pass (pytest)
- Event bus emits and receives all 6 signal types
- Config loads YAML and persists JSON state
- Logging writes to both files with plugin attribution
- Safe write prevents race conditions in tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-01-SUMMARY.md`
</output>

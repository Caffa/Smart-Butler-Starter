---
phase: 01-core-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/core/plugin_manager.py
  - src/core/task_queue.py
  - src/core/capabilities.py
  - src/plugins/base.py
  - tests/core/test_plugin_manager.py
  - tests/core/test_task_queue.py
autonomous: true
requirements:
  - CORE-02
  - CORE-04
  - CORE-07
must_haves:
  truths:
    - Plugin system auto-discovers and loads enabled plugins on startup
    - Smart throttling defers tasks when CPU/RAM/power conditions exceed thresholds
    - Task queue with SQLite backend provides crash recovery
    - Capability registry allows plugins to expose/consume features without hard dependencies
  artifacts:
    - path: src/core/plugin_manager.py
      provides: Plugin auto-discovery and lifecycle
      exports: ["PluginManager", "discover_plugins"]
    - path: src/core/task_queue.py
      provides: Background task processing
      exports: ["queue", "throttled", "ThrottledException"]
    - path: src/core/capabilities.py
      provides: Feature registry for loose coupling
      exports: ["CapabilityRegistry", "register_capability", "get_capability"]
    - path: src/plugins/base.py
      provides: Base plugin class
      exports: ["BasePlugin"]
  key_links:
    - from: src/core/plugin_manager.py
      to: src/core/event_bus.py
      via: Event subscriptions during plugin init
      pattern: "plugin.connect_events(event_bus)"
    - from: src/core/task_queue.py
      to: src/core/event_bus.py
      via: Task completion emits events
      pattern: "note_written.send(...)"
    - from: src/plugins/base.py
      to: src/core/capabilities.py
      via: self.register_capability() in on_enable()
      pattern: "self.capabilities.register(...)"
---

<objective>
Build infrastructure layer: plugin system, task queue with throttling, and capability registry.
These components orchestrate plugin behavior and background processing.

Purpose: Enable dynamic plugin loading, background task processing with resource awareness,
and loose coupling via capability registry.

Output: Plugin manager with auto-discovery, Huey-based task queue, throttling decorators,
and capability system. Ready for voice and writer plugins.
</objective>

<execution_context>
@/Users/caffae/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Capability Registry</name>
  <files>src/core/capabilities.py, tests/core/test_capabilities.py</files>
  <action>
    Create capability registry for loose plugin coupling:
    - Register capabilities by name: register_capability("transcription", transcribe_func)
    - Get capabilities: get_capability("transcription")
    - Check availability: has_capability("transcription")
    - Plugin declares capabilities in manifest, loaded on enable
    - Thread-safe registry (plugins load in parallel)
    
    Use cases:
    - Router plugin gets "classifier" capability from AI layer
    - Memory plugin gets "embeddings" capability from ChromaDB
    - Graceful degradation if capability unavailable
    
    Test: Register/get/has operations, multiple capabilities, concurrent access.
  </action>
  <verify>python -m pytest tests/core/test_capabilities.py -v</verify>
  <done>Capabilities register and resolve; thread-safe; missing capabilities handled gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Plugin Base Class and Manifest</name>
  <files>src/plugins/base.py, src/plugins/manifest.py, tests/plugins/test_base.py</files>
  <action>
    Create base plugin architecture:
    - BasePlugin abstract class with lifecycle methods:
      - on_enable(): Plugin starting up
      - on_disable(): Plugin shutting down
      - connect_events(event_bus): Subscribe to signals
    - Manifest schema (plugin.yaml):
      - name, version, description
      - enabled (bool)
      - capabilities_provided[]
      - capabilities_required[]
      - events_listens[]
      - events_emits[]
      - dependencies[] (other plugin names)
    - Manifest validation
    - Plugin metadata access
    
    Test: Base plugin subclass, manifest loading, validation errors.
  </action>
  <verify>python -m pytest tests/plugins/test_base.py -v</verify>
  <done>BasePlugin subclassable; manifest validates; lifecycle methods called</done>
</task>

<task type="auto">
  <name>Task 3: Plugin Manager with Auto-Discovery</name>
  <files>src/core/plugin_manager.py, tests/core/test_plugin_manager.py</files>
  <action>
    Implement plugin manager:
    - Scan plugins/ directory for plugin.yaml files
    - Load enabled plugins in dependency order
    - Instantiate plugin classes
    - Call on_enable() for each
    - Connect events via connect_events()
    - Register capabilities
    - Handle load failures gracefully (log error, continue)
    - Support plugin reload (dev mode)
    
    Directory structure:
    plugins/
      voice_input/
        __init__.py
        plugin.yaml
      daily_writer/
        __init__.py
        plugin.yaml
    
    API:
    - load_plugins(): Discover and load all
    - get_plugin(name): Get loaded instance
    - list_plugins(): List all available
    - enable/disable_plugin(name): Toggle
    
    Test: Discovery, loading order, event connection, error handling.
  </action>
  <verify>python -m pytest tests/core/test_plugin_manager.py -v</verify>
  <done>Plugins auto-discover; load in dependency order; events connected; failures handled</done>
</task>

<task type="auto">
  <name>Task 4: Task Queue with Huey</name>
  <files>src/core/task_queue.py, tests/core/test_task_queue.py</files>
  <action>
    Set up Huey task queue:
    - Initialize SqliteHuey with ~/.butler/data/tasks.db
    - Enable results storage for crash recovery
    - Task decorator wrapper around @huey.task()
    - Periodic task support for scheduled jobs
    - Task retry configuration (default: 3 retries, 60s delay)
    
    Integration:
    - Tasks can emit events via event_bus
    - Tasks receive logger via dependency injection
    
    Test: Task execution, retry behavior, periodic tasks, crash recovery.
  </action>
  <verify>python -m pytest tests/core/test_task_queue.py -v && huey_consumer.py --help</verify>
  <done>Tasks execute; retries work; SQLite persists; consumer starts</done>
</task>

<task type="auto">
  <name>Task 5: Smart Throttling</name>
  <files>src/core/throttling.py, tests/core/test_throttling.py</files>
  <action>
    Implement throttling decorator:
    - Check CPU usage (psutil.cpu_percent)
    - Check RAM usage (psutil.virtual_memory)
    - Check power status (battery/plugged)
    - Configurable thresholds via decorator args
    - Raise ThrottledException when limits exceeded
    - Integrate with Huey retry mechanism
    
    Decorator signature:
    @throttled(max_cpu=60, max_ram=80, require_power=False)
    def heavy_task(): ...
    
    Integration with task_queue:
    - ThrottledException triggers Huey retry
    - Exponential backoff on throttle
    
    Test: CPU threshold, RAM threshold, power detection, retry behavior.
  </action>
  <verify>python -m pytest tests/core/test_throttling.py -v</verify>
  <done>Throttling detects high load; defers tasks; retries when system idle</done>
</task>

</tasks>

<verification>
1. Plugin load test: Place test plugin in plugins/, verify auto-discovery
2. Integration test: Plugin emits event, another plugin receives via event bus
3. Throttling test: Artificially high CPU, verify task deferral
4. Crash recovery test: Kill consumer mid-task, verify resume on restart
5. Capability test: Plugin A registers, Plugin B uses, no direct import
</verification>

<success_criteria>
- Plugins auto-discover from filesystem
- Plugin load order respects dependencies
- Task queue executes background jobs
- Throttling defers when system busy
- Capabilities enable loose coupling
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-02-SUMMARY.md`
</output>

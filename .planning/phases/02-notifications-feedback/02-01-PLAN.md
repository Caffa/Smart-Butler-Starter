---
phase: 02-notifications-feedback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugins/notifications/__init__.py
  - src/plugins/notifications/plugin.py
  - src/plugins/notifications/plugin.yaml
  - src/plugins/notifications/audio.py
  - src/plugins/notifications/notifier.py
  - src/plugins/notifications/config.py
autonomous: true
requirements:
  - NOTIFY-01
  - NOTIFY-02
  - NOTIFY-03
must_haves:
  truths:
    - User sees macOS notification when note is successfully written
    - Audio tone plays when Butler starts processing voice input
    - Different tones indicate success, waiting, and failure states
    - Notification plugin can be disabled without breaking other features
  artifacts:
    - path: src/plugins/notifications/plugin.py
      provides: Main plugin with event subscriptions
      min_lines: 100
      exports: NotificationsPlugin
    - path: src/plugins/notifications/audio.py
      provides: Audio feedback via afplay
      min_lines: 50
      exports: play_success_sound, play_waiting_sound, play_error_sound
    - path: src/plugins/notifications/notifier.py
      provides: macOS notification delivery via terminal-notifier
      min_lines: 80
      exports: NotificationService
    - path: src/plugins/notifications/plugin.yaml
      provides: Plugin manifest
      contains: name, version, events
  key_links:
    - from: src/plugins/notifications/plugin.py
      to: src/core/event_bus.note_written
      via: SignalSubscription.connect()
      pattern: "note_written.connect"
    - from: src/plugins/notifications/plugin.py
      to: src/core/event_bus.pipeline_error
      via: SignalSubscription.connect()
      pattern: "pipeline_error.connect"
    - from: src/plugins/notifications/audio.py
      to: /System/Library/Sounds/
      via: subprocess.run afplay
      pattern: "afplay.*Glass.*afplay.*Pop.*afplay.*Basso"
    - from: src/plugins/notifications/notifier.py
      to: terminal-notifier
      via: subprocess.run
      pattern: "terminal-notifier.*-title.*-message"
    - from: src/plugins/notifications/plugin.py
      to: src/core/config
      via: get_config()
      pattern: "get_config.*muted"
---

<objective>
Create notifications plugin with macOS notifications and audio feedback for Butler activity.

Purpose: Users receive immediate feedback on Butler's activity through visual and audio cues.

Output:

- Plugin in src/plugins/notifications/ with event subscriptions to note_written and pipeline_error
- Audio module using system sounds (Glass, Pop, Basso) via afplay
- Notification service using terminal-notifier CLI
- Graceful degradation when system tools unavailable
  </objective>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-notifications-feedback/02-CONTEXT.md
@.planning/phases/02-notifications-feedback/02-RESEARCH.md
@src/plugins/base.py
@src/core/event_bus.py
@src/plugins/daily_writer/plugin.py
</context>

<tasks>

<task type="auto">
  <name>Create notifications plugin structure and manifest</name>
  <files>src/plugins/notifications/__init__.py, src/plugins/notifications/plugin.yaml</files>
  <action>
Create the notifications plugin directory with:

1. **init**.py exporting NotificationsPlugin
2. plugin.yaml with:
   - name: notifications
   - version: 1.0.0
   - description: "macOS notifications and audio feedback"
   - events_subscribed: [note.written, pipeline.error]
   - capabilities_provided: []
   - dependencies: [] (zero hard deps per NOTIFY-03)

Use existing plugin.yaml patterns from daily_writer.
</action>
<verify>
ls -la src/plugins/notifications/ shows **init**.py and plugin.yaml
grep -q "name: notifications" src/plugins/notifications/plugin.yaml
grep -q "note.written" src/plugins/notifications/plugin.yaml
</verify>
<done>Plugin directory exists with manifest declaring event subscriptions</done>
</task>

<task type="auto">
  <name>Implement audio feedback module with system sounds</name>
  <files>src/plugins/notifications/audio.py</files>
  <action>
Create audio.py with:

1. SYSTEM_SOUNDS_PATH = Path("/System/Library/Sounds")
2. Function play_success_sound() - plays Glass.aiff (pleasant, confirmation)
3. Function play_waiting_sound() - plays Pop.aiff (neutral, attention)
4. Function play_error_sound() - plays Basso.aiff (attention, failure)
5. Each function:
   - Checks if system tool (afplay) available via shutil.which()
   - Returns False gracefully if not available
   - Uses subprocess.run with timeout
   - Logs warning if sound file missing
6. Mute check: Accept muted parameter, skip if True

Implementation per RESEARCH.md patterns.
</action>
<verify>
python3 -c "from src.plugins.notifications.audio import play_success_sound, play_waiting_sound, play_error_sound; print('imports ok')"
grep -q "Glass" src/plugins/notifications/audio.py
grep -q "Pop" src/plugins/notifications/audio.py
grep -q "Basso" src/plugins/notifications/audio.py
</verify>
<done>Audio module imports successfully, uses system sounds Glass/Pop/Basso via afplay</done>
</task>

<task type="auto">
  <name>Implement notification service and main plugin</name>
  <files>src/plugins/notifications/notifier.py, src/plugins/notifications/plugin.py</files>
  <action>
Create notifier.py with NotificationService class:

1. send_note_notification(path, source, word_count, text_preview):
   - Format display path (vault/folder/file.md not full path)
   - Truncate text_preview to ~50 chars with "..." if longer
   - Title: "Note Saved"
   - Message: "{text_preview} | {vault/folder/file.md} | {word_count} words"
   - Use terminal-notifier with -title, -message, -sound Glass
   - On click: obsidian://open?path={path}
2. send_error_notification(error, context):
   - Title: "Butler Error"
   - Message: "{emoji} {error truncated}" (emoji based on context.get("stage"))
   - Use -sound Basso
   - On click: open log file
3. Graceful degradation: check shutil.which("terminal-notifier"), log warning if missing

Create plugin.py with NotificationsPlugin(BasePlugin):

1. **init**: Check dependencies (\_terminal_notifier_available, \_afplay_available)
2. \_load_config(): Get notifications.muted from global config
3. connect_events():
   - Subscribe to note_written via SignalSubscription
   - Subscribe to pipeline_error via SignalSubscription
4. \_on_note_written: Call notifier.send_note_notification() with text_preview (first ~50 chars from note content)
5. \_on_pipeline_error: Call notifier.send_error_notification()
6. on_enable/on_disable: Standard lifecycle, connect/disconnect events

Per CONTEXT.md: Success shows vault/folder/file, error shows emoji + "View log".
</action>
<verify>
python3 -c "from src.plugins.notifications.plugin import NotificationsPlugin; print('plugin imports ok')"
grep -q "terminal-notifier" src/plugins/notifications/notifier.py
grep -q "SignalSubscription" src/plugins/notifications/plugin.py
grep -q "note_written" src/plugins/notifications/plugin.py
grep -q "pipeline_error" src/plugins/notifications/plugin.py
</verify>
<done>Plugin subscribes to note_written and pipeline_error, sends notifications via terminal-notifier</done>
</task>

</tasks>

<verification>
- Plugin can be loaded without errors: python3 -c "from src.plugins.notifications import NotificationsPlugin; print('loaded')"
- Event subscriptions configured: grep "note_written\|pipeline_error" src/plugins/notifications/plugin.py
- Audio uses system sounds: grep "Glass\|Pop\|Basso" src/plugins/notifications/audio.py
- Zero hard Python dependencies: grep "import subprocess" src/plugins/notifications/ files
- Graceful degradation: grep "shutil.which" src/plugins/notifications/
</verification>

<success_criteria>

- [x] User sees macOS notification when note is successfully written
- [x] Audio tone plays when Butler starts processing voice input (via note_written event)
- [x] Different tones indicate success (Glass), waiting (Pop), failure (Basso) states
- [x] Notification plugin can be disabled without breaking other features (zero hard deps, graceful degradation)
      </success_criteria>

<output>
After completion, create `.planning/phases/02-notifications-feedback/02-01-SUMMARY.md`
</output>
